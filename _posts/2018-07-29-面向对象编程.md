---
layout: post
title: 面向对象
data: 2018-07-29 09:00:00 +800
categories: front-end js
tags: js
excerpt: 我的一个薄弱点，面向对象。
---

#### 基本概念
+ 用一个句子说明"The black cat sleeps on my head"
+ `对象`——"事物"在程序语言中的表现形式,有时候也叫实例,例如"cat"
+ `属性`对象的特征，例如"black"
+ `方法`对象的动作，例如"sleeps"
+ `类`是一种模板，例如猫属于猫科动物，具有猫科动物的一些特性，而猫科动物就是一个类
+ `封装`
+ `聚合`将多个对象合而为一的能力
+ `继承`对现有代码的重用
+ `多态`

#### 函数
回调函数的好处，例如：
``` js
function multipage(a,b,c) {
    var i, ar = [];
    for(i = 0; i < 3; i++) {
        ar[i] = arguments[i] * 2;
    }
    return ar;
}
function addOne(a) {
    return a + 1;
}
// 合并
function multipage(a, b, c, callback) {
    var i, ar = [];
    for(i = 0; i < 3; i++) {
        ar[i] = callback(arguments[i] * 2);
    }
    return ar[i];
}
// 调用
multipage(1, 2, 3, function(a) {
    return a + 1;
});
```
闭包
+ 作用域链：函数可以访问的变量来自自身作用域以及“父级作用域”，这就形成了一条作用域链
+ 闭包1
``` js
var a = "global variable";
var F = function() {
    var b = "local variable";
    var N = function() {
        var c = "inner local";
        return b;
    };
    return N;
}
var inner = F();
inner(); // "local variable"
```
+ 闭包2
``` js
var inner;
var F = function() {
    var b = "local variable";
    var N = function() {
        return b;
    };
    inner = N;
}
F();
```
+ 闭包3：函数在其父级函数返回之后留住对父级作用域的链接
``` js
function fn(param) {
    var N = function() {
        return param;
    };
    param++;
    return N;
};
var inner = fn(123);
inner();
```
+ 循环中的闭包
``` js
function fn() {
    var arr = [], i;
    for(i = 0; i < 3; i++) {
        arr[i] = function() {
            return i;
        };
    }
    return arr;
}
var arr = fn();
arr[0](); // 3
arr[1](); // 3
arr[2](); // 3
```
+ 原因：在这里创建了三个闭包，而他们都指向了一个共同的局部变量i
``` js
function fn() {
    function binder(x) {
        return function() {
            return x;
        };
    }

    var arr = [], i;
    for(i = 0; i < 3; i++) {
        arr[i] = binder(i);
    }
    return arr;
}
```
+ getter与setter
``` js
var getValue, setValue;
(function() {
    var secret = 0;
    getValue = function() {
        return secret;
    };
    setValue = function(v) {
        if(typeof v === "number") {
            secret = v;
        }
    };
}());
```
+ 迭代器
``` js
function setup(x) {
    var i = 0;
    return function() {
        return x[i++];
    };
}
var next = setup(['a', 'b', 'c']);
next(); // a
next(); // b;
```
#### 对象
+ 使用this值,指向当前对象
``` js
var hero = {
    name: 'Rafaelo',
    sayName: function() {
        return this.name;
    }
};
hero.sayName(); // 'Rafaelo'
```
+ 构造器函数（好处是创建对象时接收一些参数）
``` js
function Hero(name) {
    this.name = name;
    this.occupation = 'Ninja';
    this.whoAreYou = function() {
        return "I'm " + this.name + " and I'm a " + this.occupation;
    };
}
var h1 = new Hero('blabla');
var h2 = new Hero('albalb');
h1.whoAreYou();
h2.whoAreYou();
```
+ 构造器属性
``` js
// 接上面代码
h2.constructor; // function Hero(name)...
var h3 = new h2.constructor('aaa');
h3.name; // aaa
```
+ prototype
* 每个函数的prototype属性中都指向了一个对象
* 它只有在该函数是构造器时才发挥作用
* 该函数创建的所有对象都会持有该prototype属性的引用，并且可以当自身属性来使用
+ call()与apply()
``` js
var some_obj = {
    name: 'Ninja',
    say: function(who) {
        return 'Haya ' + who + ', I am a ' + this.name;
    }
};
// 
var my_obj = { name: 'Scripting guru' };
some_obj.say.call(my_obj, 'Dude'); // 'Haya Dude, I am a Scripting guru'
// 等同于
some_obj.say.apply(my_obj, ['Dude']);
```
+ 判断对象类型
* '[object object]'`Object.prototype.toString.call({})`
* '[object Array]'`Object.prototype.toString.call([])`
利用原型添加属性和方法
``` js
function Gadget(name, color) {
    this.name = name;
    this.color = color;
    this.whatAreYou = function() {
        return 'I am s ' + this.color + ' ' + this.name;
    };
}
// Gadget.prototype.price = 100;
// Gadget.prototype.rating = 3;
/* Gadget.prototype.getInfo = function() {
    return 'Rating: ' + this.rating + ', price: ' + this.price;
} */
// 与上面的写法在constructor时有区别
Gadget.prototype = {
    price: 100,
    rating: 3,
    getInfo: function() {
         return 'Rating: ' + this.rating + ', price: ' + this.price;
    }
}
//
var newtoy = new Gadget('xxx', 'black');
newtoy.name; // xxx
newtoy.color; // black
newtoy.whatAreYou(); // I am a black xxx
newtoy.price; // 100
newtoy.rating; // 3
newtoy.getInfo(); // Rating: 3, price: 100
Gadget.prototype.get = function(what) {
    return this[what];
};
newtoy.get('color'); // black
```
使用`hasOwnProperty('name');` 判断是否为自身属性
+ `__proto__`
``` js
var monkey = {
    feeds: 'bananas',
    breathes: 'air'
}
function Human() { };
Human.prototype = monkey;
var developer = new Human();
developer.feeds = 'pizza';
developer.hacks = 'JS';
developer.__proto__ === monkey;
```