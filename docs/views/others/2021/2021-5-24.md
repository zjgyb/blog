---
title: 【2021-05】打卡
date: 2021-05-24
categories: 其他
tags:
 - 打卡
---

## 5.25

**一个组件的data选项必须是一个函数**，从下图中可以看到，定义原型上的属性在实例化后，如果修改data，则会造成属性之间相互影响

```ts
function MyComponent() {
    this.data = data;
}

MyComponent.prototype.data = {
    a: 1,
    b: 2
}

const a = new MyComponent();
const b = new MyComponent();

a.data.a = 2;
console.log(b.data.a); // 2

function MyComponent() {
    this.data = this.data();
}

MyComponent.prototype.data = () => {
    return {
        a: 1,
        b: 2
    }
}

a.data.a = 2;
console.log(b.data.a); // 1
```

看源码在initData中也可以看出来，如果data是一个函数，则运行函数，否则直接是data，如果data是一个对象，那么每个生命的组件之间都会影响到这个data，因此必须使用函数来获取一份独一无二的data

```js
function initData (vm: Component) {
  let data = vm.$options.data
  data = vm._data = typeof data === 'function'
    ? getData(data, vm)
    : data || {}
}
```

---分割线---

今天学到了一种用法，在跳转详情的时候往往会销毁组件，然后返回时原先的筛选条件消失，如何解决这一问题。一开始想的是用`sessionStorage`的方式，跳转的时候保存数据，返回的时候获取存储的数据。

今天看到更好的解决方案就是是使用`keep-alive`，在跳转详情的时候把界面用`keep-alive`临时缓存下来，即白名单的方式，然后在跳转其他界面的时候去掉白名单内的界面，这样就很方便的保存内容了。

主要用到的是`Vue.observable(object)`，然后动态的改变白名单`whiteLists`

## 5.24

由于个人比较懒惰，加上前一段时间项目比较忙，造成有一段时间没有学习了，但是想想不能这么下去了，还是得持续学习，因此记录记录最近在干的事，学习新知识。

TypeScript中interface和type的区别

1. 继承方式

`interface`使用`extends`继承，`type`使用`&`继承

2. interface独有

`interface`可以重复声明，然后里面的变量自动合并，例如：

```ts
interface A {
    name: string;
}

interface A {
    age: number;
}
```

`interface`设置可选属性、只读属性

3. `type`独有

可以声明基本类型别名、联合类型、元组

```ts
type A = {
    name: string;
}

type B = {
    age: number;
}

type C = A | B;
type D = [A, B];
```